---
title: 链表
date: 2019-03-29 17:11:09
categories:
  - 数据结构
tags:
  - 链表
abbrlink: 2362a8ea
updated:
---
# 链表
{% blockquote 百度百科 https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fr=aladdin 链表 %}
链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的存取和操作。程序语言或面向对象语言，如C,C++和Java依靠易变工具来生成链表。
{% endblockquote %}
<!--more-->
# 代码
```cpp
#include <stdio.h>
#include <stdlib.h>
typedef int ElemType;
typedef struct Node {
    ElemType data;
    struct Node *next;
}Node,*LinkedList;
LinkedList LinkedListInit() {
    Node *L;
    L = (Node *)malloc(sizeof(Node));
    if(L == NULL) {
        printf("申请内存空间失败\n");
    }
    L->next = NULL;
 	return L;
}
LinkedList LinkedListCreatH_pre() {
    Node *L,*t;
    t = L = (Node *)malloc(sizeof(Node));
    ElemType x;
    while(scanf("%d",&x) != EOF) {
        Node *p;
        p = (Node *)malloc(sizeof(Node));
        p->data = x;
        t->next = p;
        p->next=NULL;
        t = t->next;
    }
    return L;
}
LinkedList LinkedListCreatH_back() {
    Node *L;
    L = (Node *)malloc(sizeof(Node));
    L->next = NULL;
    ElemType x;
    while(scanf("%d",&x) != EOF) {
        Node *p;
        p = (Node *)malloc(sizeof(Node));
        p->data = x;
        p->next = L->next;
        L->next = p;
    }
    return L;
}
LinkedList LinkedListInsert(LinkedList L,int i,ElemType x) {
    Node *pre=L;
    int tempi = 0;
    for (tempi = 1; tempi < i; tempi++) {
    	pre = pre->next;
	}
    Node *p;
    p = (Node *)malloc(sizeof(Node));
    p->data = x;
    p->next = pre->next;
    pre->next = p;
    return L;
}
LinkedList LinkedListFind(LinkedList L,ElemType x)
{
    int i=1;
    Node *p=L->next;
    while(p->data != x) {
        if(p->next==NULL)
        {
            printf("没有此数！\n");
            return L;
        }
        p = p->next;
        i++;
    }
    printf("%d位于第%d个位置！\n",x,i);
    return L;
}
LinkedList LinkedListDelete(LinkedList L,ElemType x)
{
    Node *p,*pre=L;
    p = L->next;
    while(p->data != x) {
        if(p->next==NULL)
        {
            printf("没有此数！\n");
            return L;
        }
        pre = p;
        p = p->next;
    }
    pre->next = p->next;
    free(p);
    return L;
}
void menu()
{
	printf("1.输入(前插)\n");
	printf("2.输入(后插)\n");
	printf("3.插入数据\n");
	printf("4.查找数据\n");
	printf("5.删除数据\n");
	printf("0.退出程序\n");
}
int main()
{
    LinkedList list,start;
    int choice;
    while(true)
    {
    	system("CLS");
    	menu();
    	scanf("%d",&choice);
    	switch(choice)
    	{
    		case 1:
    		{
    			printf("请输入单链表的数据：");
			    list = LinkedListCreatH_pre();
			    for(start = list->next; start != NULL; start = start->next) {
			    	printf("%d ",start->data);
				}
			    printf("\n");
			    break;
    		}
    		case 2:
    		{
    			printf("请输入单链表的数据：");
			    list = LinkedListCreatH_back();
			    for(start = list->next; start != NULL; start = start->next) {
			    	printf("%d ",start->data);
				}
			    printf("\n");
			    break;
    		}
    		case 3:
    		{
    			int i;
			    ElemType x;
			    printf("请输入插入数据的位置：");
			    scanf("%d",&i);
			    printf("请输入插入数据的值：");
			    scanf("%d",&x);
			    LinkedListInsert(list,i,x);
			    for(start = list->next; start != NULL; start = start->next) {
			    	printf("%d ",start->data);
				}
			    printf("\n");
			    break;
    		}
    		case 4:
    		{
    			ElemType x;
    			printf("请输入要查找的元素的值：");
			    scanf("%d",&x);
			    LinkedListFind(list,x);
			    for(start = list->next; start != NULL; start = start->next) {
			    	printf("%d ",start->data);
				}
			    printf("\n");
			    break;
    		}
    		case 5:
    		{
    			ElemType x;
    			printf("请输入要删除的元素的值：");
			    scanf("%d",&x);
			    LinkedListDelete(list,x);
			    for(start = list->next; start != NULL; start = start->next) {
			    	printf("%d ",start->data);
				}
			    printf("\n");
			    break;
    		}
    		case 0:return 0;
    	}
    	system("PAUSE");
    }
    return 0;
}
```