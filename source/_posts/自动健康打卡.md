---
title: 自动健康打卡
categories:
- 编程语言
- Python
tags: Python
abbrlink: '934e7461'
date: 2020-12-01 11:56:35
---
自动健康打卡(逃

建议使用Coding定时构建，强烈不推荐使用国外服务器，包括github action。
**因当天打卡系统异常造成无法打卡时，需等待打卡系统正常后自行打卡或手动触发构建计划。**

**本文档以及代码可能会不定时更新，修复和优化，部署成功的能不能在下面留言告诉一下，且留意本文章是否更新，最后更新时间可以看最上方。**
<!--more-->

# 配置文件
注意将config.ini配置项进行修改，申请AK和SK教程见后文。
```ini config.ini
[Basic]
;现居住地 1: 二七区; 2:学校
LOCAL_ADDR = 2
;是否修改IP地址
CHANGE_ADDR = True
;自定义IP地址
IP_ADDR = 223.90.40.4

[API]
;百度智能云 文字识别OCR AK
API_KEY = your_api_key
;百度智能云 文字识别OCR SK
SECRET_KEY = your_secret_key

[User]
;昵称: ['账号', '密码', '监护人', '监护人联系电话', '户籍地']
sample_user: ['username', 'password', 'XXX', 'XXXXXXXXXXX', '河南省焦作市']

```
添加用户信息，账号密码为[统一认证](https://uia.hpu.edu.cn)账号密码。
如需多用户，可在`[User]`下按示例添加新行，注意都为英文符号，昵称随便起，可以为中文。

上述AK以及SK需前往[百度智能云](https://console.bce.baidu.com/ai/#/ai/ocr/app/list)申请文字识别OCR API。
点击创建应用，依次填写应用名称，文字识别包名为不需要，应用归属为个人，应用描述后，点击立即创建，返回应用列表，即可得到API Key和Secret Key。


# 完整代码
以下是完整代码main.py，无需更改，按之后步骤要求进行上传。

```py main.py
"""自动健康打卡"""
from __future__ import absolute_import

import ast
import configparser
import logging
import random
import re
import time

import requests
from bs4 import BeautifulSoup
from retrying import retry

# 固定链接，不建议修改
URL_MAP = {
    'HOST': 'https://ehall.hpu.edu.cn/infoplus/form/XSMRJKSB/start',
    'START': 'https://ehall.hpu.edu.cn/infoplus/interface/start',
    'ALIVE': 'https://ehall.hpu.edu.cn/infoplus/alive',
    'CAPTCHA': 'https://uia.hpu.edu.cn/sso/apis/v2/open/captcha?date=',
    'LOGIN': 'https://uia.hpu.edu.cn/cas/login',
    'RENDER': 'https://ehall.hpu.edu.cn/infoplus/interface/render',
    'PROCESS': 'https://ehall.hpu.edu.cn/infoplus/interface/instance/[id]/progress',
    'NEXTSTEP': 'https://ehall.hpu.edu.cn/infoplus/interface/listNextStepsUsers',
    'DOACTION': 'https://ehall.hpu.edu.cn/infoplus/interface/doAction',
    'CHECK': 'https://ehall.hpu.edu.cn/taskcenter/api/me/processes/done?limit=1&start=0',
    'API': 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=[ak]&client_secret=[sk]',
    'REQUEST_URL': 'https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic'
}

# 请求头，可以按需更改
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/78.0.3904.108 Safari/537.36 QIHU 360EE'
}


class ReadConfig:
    """读取配置文件类"""

    def __init__(self, filename):
        """配置文件读取初始化"""
        self.config = configparser.ConfigParser()
        self.config['Basic'] = {
            'CHANGE_DATA': True,
            'CHANGE_ADDR': True,
            'IP_ADDR': '223.90.40.4'
        }
        self.config.read(filename, encoding='utf-8')

    def get_basic(self, param):
        """获取Basic配置"""
        value = self.config.get('Basic', param)
        return value

    def get_api(self, param):
        """获取API配置"""
        value = self.config.get('API', param)
        return value

    def get_user(self):
        """获取User配置"""
        value = self.config.items('User')
        return value


class Bot:
    """自动健康打卡类"""

    def __init__(self, config_file):
        """打卡初始化"""
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger('AutoReport')
        self.logger.info('程序启动中...')

        # 读取配置文件
        self.data = ReadConfig(config_file)
        self.addr = self.data.get_basic('LOCAL_ADDR')
        self.chaddr = self.data.get_basic('CHANGE_ADDR')
        self.ipaddr = self.data.get_basic('IP_ADDR')

        self.api_key = self.data.get_api('API_KEY')
        self.secret_key = self.data.get_api('SECRET_KEY')

        # 登录并打卡
        for user in self.data.get_user():
            self.sessions = requests.session()
            self.login(user)
            self.post(user)
            self.sessions.close()

    @retry(stop_max_attempt_number=3)
    def login(self, user):
        """登录"""
        self.logger.info('%s开始登录中...', user[0])

        # 登录页面
        req = self.sessions.get(URL_MAP['HOST'], headers=HEADERS, timeout=5)
        req = self.sessions.get(req.url, headers=HEADERS, timeout=5)
        soup = BeautifulSoup(req.content, features="html.parser")
        form = soup.find_all('input', class_='for-form')

        # 验证码获取
        captcha = URL_MAP['CAPTCHA'] + str(int(round(time.time() * 1000)))
        req = self.sessions.get(captcha, headers=HEADERS, timeout=5)
        img = ast.literal_eval(req.content.decode('utf-8'))['img']
        self.logger.info('验证码获取成功!')

        # 验证码识别
        api = URL_MAP['API'].replace('[ak]', self.api_key).replace('[sk]', self.secret_key)
        response = requests.get(api)
        access_token = response.json()['access_token']
        request_url = URL_MAP['REQUEST_URL'] + "?access_token=" + access_token
        api_headers = {'content-type': 'application/x-www-form-urlencoded'}
        response = requests.post(request_url, data={'image': img}, headers=api_headers, timeout=5)
        captcha = response.json()['words_result'][0]['words']
        captcha = str(captcha.replace('=?', '')).split('+')
        captcha = sum(map(int, captcha))
        self.logger.info('验证码识别成功!')

        # 构造表单
        token = ast.literal_eval(req.content.decode('utf-8'))['token']
        account = ast.literal_eval(user[1])
        formdata = {
            'username': account[0],
            'password': account[1],
            '_eventId': 'submit',
            'token': token
        }
        formdata.update({f['name']: f['value'] for f in form})
        formdata.update({'captcha': captcha})

        # 登录
        req = self.sessions.post(URL_MAP['LOGIN'], headers=HEADERS, data=formdata, timeout=5)
        soup = BeautifulSoup(req.content, features='html.parser')
        errormes = soup.find('span', id='errormes')
        if errormes:
            self.logger.error(errormes['value'])
            raise Exception(errormes['value'])

        # 检测登录状态
        url = self.sessions.get(URL_MAP['HOST'], headers=HEADERS, timeout=5).url
        if not url == URL_MAP['HOST']:
            self.logger.error('登录失败, 未知错误!')
            raise Exception('登录失败, 未知错误!')
        else:
            self.logger.info('使用账号密码登录成功!')

    @retry(stop_max_attempt_number=3)
    def post(self, user):
        """打卡"""
        self.logger.info('打卡进行中...')
        req = self.sessions.get(URL_MAP['HOST'], headers=HEADERS, timeout=5)
        soup = BeautifulSoup(req.content, features='html.parser')

        # 构造表单
        csrf = soup.find('meta', itemscope='csrfToken')['content']
        formdata = {
            'idc': 'XSMRJKSB',
            'release': '',
            'csrfToken': csrf,
            'formData': '{"_VAR_URL":"https://ehall.hpu.edu.cn/infoplus/form/XSMRJKSB/start","_VAR_URL_Attr":"{}"}'
        }
        req = self.sessions.post(URL_MAP['START'], headers=HEADERS, data=formdata, timeout=5)
        url = req.json()['entities'][0]

        # 构造表单
        stepid = int(re.findall(r'\d+', url)[0])
        self.logger.info('开始流程%s中...', stepid)
        formdata = {
            'stepId': stepid,
            'instanceId': '',
            'admin': 'false',
            'rand': random.random() * 999,
            'width': '1747',
            'lang': 'zh',
            'csrfToken': csrf
        }
        HEADERS.update({'Referer': url})
        req = self.sessions.post(URL_MAP['RENDER'], headers=HEADERS, data=formdata, timeout=5)
        self.logger.info('已加载审批表!')
        form = req.json()['entities'][0]

        # 构造表单
        instanceid = form['step']['instanceId']
        formdata = {
            'stepId': stepid,
            'includingTop': 'true',
            'csrfToken': csrf,
            'lang': 'zh'
        }
        req = self.sessions.post(URL_MAP['PROCESS'].replace('[id]', instanceid), headers=HEADERS, data=formdata, timeout=5)
        self.logger.info('审批表处理中...')
        timestamp = req.json()['entities'][0]['remarks'][0]['assignTime']
        boundfields = ','.join(list(form['data'].keys()))

        # 构造表单
        postdata = form['data']
        account = ast.literal_eval(user[1])
        fixdata = {
            'fieldSQjhr': account[2],
            'fieldSQjhrlxdh': account[3],
            'fieldSQhjd': account[4],
            'fieldTXxjzdlx': '1',
            'fieldTXsfqgyq': '未去过重点疫区',
            'fieldTXsfqgyq_Name': '未去过重点疫区',
            'fieldTXsfjc': '2',
            'fieldTXcjtw': '36.6-36.9',
            'fieldTXcjtw_Name': '36.6-36.9',
            'fieldTXsfyc': '2',
            'fieldTXsfjcqk': '',
            'fieldTXsfjcqk_Name': '',
            'fieldTXzz': '',
            'fieldTXzz_Name': '',
            'fieldTXzz1': '',
            'fieldTXycjg': '',
            'fieldTXycjg_Name': '',
            'fieldTXycjgqt': '',
            'fieldTXzlcs': ''
        }
        postdata.update(fixdata)
        if self.addr == '1':
            fixdata = {
                'fieldTXsf': '410000',
                'fieldTXsf_Name': '河南省',
                'fieldTXcs': '410100',
                'fieldTXcs_Name': '郑州市',
                'fieldTXcs_Attr': '{\"_parent\":\"410000\"}',
                'fieldTXdq': '410103',
                'fieldTXdq_Name': '二七区',
                'fieldTXdq_Attr': '{\"_parent\":\"410100\"}',
                'fieldTXjtwz': '河南省郑州市二七区'
            }
        elif self.addr == '2':
            fixdata = {
                'fieldTXsf': '410000',
                'fieldTXsf_Name': '河南省',
                'fieldTXcs': '410800',
                'fieldTXcs_Name': '焦作市',
                'fieldTXcs_Attr': '{\"_parent\":\"410000\"}',
                'fieldTXdq': '410811',
                'fieldTXdq_Name': '山阳区',
                'fieldTXdq_Attr': '{\"_parent\":\"410800\"}',
                'fieldTXjtwz': '河南理工大学'
            }
        postdata.update(fixdata)
        if self.chaddr:
            postdata.update({'_VAR_ADDR': self.ipaddr})
        formdata = {
            'stepId': stepid,
            'actionId': 1,
            'formData': str(postdata),
            'timestamp': timestamp,
            'rand': random.random() * 999,
            'boundFields': boundfields,
            'csrfToken': csrf,
            'lang': 'zh'
        }
        req = self.sessions.post(URL_MAP['NEXTSTEP'], headers=HEADERS, data=formdata, timeout=5)
        if req.json()['ecode'] == 'SUCCEED':
            self.logger.info('健康打卡准备阶段, 成功!')
        else:
            raise Exception('健康打卡准备阶段, 失败!')

        # 构造表单
        formdata = {
            'actionId': 1,
            'formData': str(form['data']),
            'remark': '',
            'rand': random.random() * 999,
            'nextUsers': '{}',
            'stepId': stepid,
            'timestamp': timestamp,
            'boundFields': boundfields,
            'csrfToken': csrf,
            'lang': 'zh'
        }
        req = self.sessions.post(URL_MAP['DOACTION'], headers=HEADERS, data=formdata, timeout=5)
        if req.json()['ecode'] == 'SUCCEED':
            self.logger.info('健康打卡填报阶段, 成功!')
        else:
            raise Exception('健康打卡填报阶段, 失败!')
        self.check()

    @retry(stop_max_attempt_number=3)
    def check(self):
        """打卡完毕后复检"""
        req = self.sessions.get(URL_MAP['CHECK'], headers=HEADERS, timeout=5)
        last_time = req.json()['entities'][0]['update']
        local_time = time.strftime("%Y/%m/%d %H:%M:%S", time.localtime(last_time))
        update = round(time.time()) - last_time
        if update > 5:
            self.logger.error('上次打卡完成于%ss前,打卡可能未成功!', update)
            raise Exception('打卡复检状态异常!')
        else:
            self.logger.info('打卡完成于%s', local_time)


if __name__ == '__main__':
    BOT = Bot('config.ini')

```

# Coding

## 创建项目
登录[Coding](https://e.coding.net/login)， 进入团队，切换到项目（左边栏点击'项目'），创建项目，选择DevOps项目。

## 创建代码仓库
切换到代码仓库，新建代码仓库，勾选启用READEME.md文件初始化项目，取消启用代码扫描，点击确认。
![](https://cdn.file.todest.cn/blog/pic/20201205164547.png)

## 上传文件
新建文件main.py，将完整代码粘贴进去，点击提交并直接确认。
![](https://cdn.file.todest.cn/blog/pic/20201205164816.png)
点击上方浏览返回文件根目录，再次创建文件Jenkinsfile (注: 无文件名后缀，请不要自行发挥)，粘贴下面代码并提交，并重复此步骤将修改好的config.ini上传。
```yml Jenkinsfile
pipeline {
  agent {
    any {
      reuseNode true
    }

  }
  stages {
    stage('检出') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: env.GIT_BUILD_REF]],
          userRemoteConfigs: [[
            url: env.GIT_REPO_URL,
            credentialsId: env.CREDENTIALS_ID
          ]]])
        }
      }
      stage('安装依赖') {
        steps {
          sh '''pip3.5 install --upgrade pip
pip3.5 install setuptools
pip3.5 install requests
pip3.5 install bs4
pip3.5 install configparser
pip3.5 install retrying'''
        }
      }
      stage('运行') {
        steps {
          sh 'python3 main.py'
        }
      }
    }
  }
```

## 创建构建计划
切换到持续集成->构建计划，创建构建计划，翻到最下面选择自定义构建过程，代码仓库选择此代码仓库，配置来源勾选上使用代码库中的Jenkinsfile，点击确认。
![](https://cdn.file.todest.cn/blog/pic/20201205165857.png)
保存并构建，确认，立即构建，等待构建成功。
![](https://cdn.file.todest.cn/blog/pic/20201205170328.png)

## 设置定时触发
点击右上角的设置修改构建计划的配置，切换到触发规则，添加定时触发，设置好触发的时期时间点击确认。
![](https://cdn.file.todest.cn/blog/pic/20201205170919.png)

## 完成并查看
如果到了这里还没有出现错误的话，那么就基本没问题了，可以在项目概览查看每次定时触发情况。
![](https://cdn.file.todest.cn/blog/pic/20201205171438.png)
也可以点击任务ID查看执行日志。
![](https://cdn.file.todest.cn/blog/pic/20201205171840.png)
最后，也可以前往[学校官网](https://ehall.hpu.edu.cn/taskcenter/workflow/done)查看打卡情况。
## 邮件通知
一般来说，以目前最新的代码，如果构建失败则打卡失败，所以添加构建失败后邮件提醒还是很有必要的。
如果想要构建失败后邮件通知的话，需要在个人账户设置->提醒设置里面开启持续集成（构建）邮件提醒。
![](https://cdn.file.todest.cn/blog/pic/20201207181947.png)
并且需要在个人账户设置->邮箱设置添加想要接收邮件的邮箱并验证邮箱。
![](https://cdn.file.todest.cn/blog/pic/20201207182447.png)
同时，在构建计划设置->通知提醒里面添加成员为自己并修改通知事件为仅失败。
![](https://cdn.file.todest.cn/blog/pic/20201207182104.png)

# 最近更改

> 2021.05.18 由于学校[统一认证](https://uia.hpu.edu.cn/)账号发生变化，使用默认密码登录后会强制跳转修改密码界面，造成打卡失败，需修改为非默认密码，并修改配置文件中的密码项。

> 2021.05.25 由于Coding发生改变，需要将Jenkinsfile的pip全都改成pip3.5，修改后Jenkinsfile的见本文。

> 2021.06.03 由于百度智能云发生变化，导致验证码识别API无法使用，需前往百度智能云[文字识别](https://console.bce.baidu.com/ai/?#/ai/ocr/overview/index)领取免费资源。