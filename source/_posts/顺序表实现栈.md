---
title: 顺序表实现栈
date: 2019-03-29 17:11:09
categories:
  - 数据结构
tags:
  - 顺序表
  - 栈
abbrlink: 924b455d
updated:
---
# 顺序表实现栈
**以下为数据结构作业**
如有错误，请指出，谢谢！
<!--more-->
```cpp
#include <stdio.h>
#include <malloc.h>
typedef int SElemType;
typedef int Status;
#define INIT_SIZE 100
#define STACKINCREMENT 10
#define Ok 1
#define Error 0
#define True 1
#define False 0
typedef struct
{
    SElemType *base;
    SElemType *top;
    int stacksize;
}SqStack;
Status InitStack(SqStack *s)
{
    s->base = (SElemType *)malloc(INIT_SIZE * sizeof(SElemType));
    if(!s->base)
    {
        puts("存储空间分配失败！");
        return Error;
    }
    s->top = s->base;
    s->stacksize = INIT_SIZE;
    return Ok;
}
Status ClearStack(SqStack *s)
{
    s->top = s->base;
    return Ok;
}
Status StackEmpty(SqStack *s)
{
    if(s->top == s->base)
        return True;
    else return False;
}
Status Destroy(SqStack *s)
{
    free(s->base);
    s->base = NULL;
    s->top = NULL;
    s->stacksize=0;
    return Ok;
}
Status GetTop(SqStack *s, SElemType &e)
{
    if(s->top == s->base)return Error;
    e = *(s->top - 1);
    return Ok;
}
Status Push(SqStack *s, SElemType e)
{
    if(s->top - s->base >= s->stacksize)
    {
        s->base = (SElemType *)realloc(s->base, (s->stacksize + STACKINCREMENT) * sizeof(SElemType));
        if(!s->base)
        {
            puts("存储空间分配失败！");
            return Error;
        }
        s->top = s->base + s->stacksize;
        s->stacksize += STACKINCREMENT;
    }
    *s->top++ = e;
    return Ok;
}
Status Pop(SqStack *s, SElemType *e)
{
    if(s->top == s->base)return Error;
    --s->top;
    *e = *(s->top);
    return Ok;
}
Status StackTraverse(SqStack *s,Status(*visit)(SElemType))
{
    SElemType *b = s->base;
    SElemType *t = s->top;
    while(t > b)visit(*b++);
    printf("\n");
    return Ok;
}
Status visit(SElemType c)
{
    printf("%d ",c);
    return Ok;
}
void stack_insert(SqStack *s)
{
    int n;
    puts("请输入要进栈的个数：");
    scanf("%d", &n);
    printf("请输入%d个数依次入栈\n",n);
    while(n--)
    {
        int m;
        scanf("%d", &m);
        Push(s, m);
    }
}
int main()
{
    int n;
    SqStack a;
    SqStack *s = &a;
    SElemType e;
    InitStack(s);
    stack_insert(s);
    StackTraverse(s, visit);
    printf("输入1入栈，输入2出栈,输入0退出！\n");
    while(scanf("%d",&n)!=EOF)
    {
        if(n==1)stack_insert(s);
        else if(n==2)
        {
            if(StackEmpty(s))printf("栈为空！\n");
            else
            {
                Pop(s, &e);
                printf("出栈的元素是：%d\n", e);
            }
        }
        else break;
        StackTraverse(s, visit);
    }
    Destroy(s);
    return 0;
}
```